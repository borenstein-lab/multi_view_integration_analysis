---
title: "Intermediate integration pipeline - microbiome data"
output:
  html_document:
    css: custom_notebook_formatting.css
    toc: true
    toc_depth: 3
    df_print: paged
    code_folding: hide
---

# 0. Preparations

```{r message=FALSE, warning=FALSE}
library(Hmisc)
library(readr)
library(stringr)
library(RColorBrewer)
library(ggplot2)
library(dplyr)
#library(igraph)
library(pheatmap)
library(cowplot)
library(kableExtra)
library(conflicted)
library(pROC)
#library(RCy3)
library(circlize)
library(patchwork)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("summarize", "dplyr")
conflict_prefer("mutate", "dplyr")

source('src/analyses/plotting_functions.R')
```

### Load files from standard ML pipeline

```{r LOAD_MISC}
load('data/ml_output/results_tables/results_for_analysis.RData', tmp_env <- new.env())
rf_results <- tmp_env$cv_results %>%
  filter(!shuffled) %>%
  group_by(
    dataset, 
    n_healthy, n_disease, 
    n_features_origin_T, 
    n_features_origin_S, 
    n_features_origin_P, 
    n_features_origin_M,
    mean_out_of_fold_test_auc) %>%
  summarise(
    sd_auc = sd(out_of_fold_test_auc, na.rm = T),
    mean_n_features_for_train = mean(n_features_for_train_final, na.rm = TRUE),
    .groups = 'drop') %>%
  rename(mean_auc = mean_out_of_fold_test_auc)
all_clusters <- tmp_env$all_clusters
rf_feat_imp_sum <- tmp_env$feat_imp_sum
rm(tmp_env)
```

### Load MintTea results

```{r LOAD_RESULTS}
res_dir <- 'data/intermediate_integration_results'
mint_rdata_ptrn <- "_results\\.RData"
mint_rdata_files <- list.files(path = res_dir, pattern = mint_rdata_ptrn)

# Place holders for MintTea results
datasets <- c()
datasets_orig_names <- c()
diablo_input <- list()
feat_pairs <- list()
latent_vars <- list()
sens_analysis_modules <- data.frame()
module_variance_expl <- list()
sens_analysis_runs <- list()
summary_aucs <- data.frame()
summary_module_aucs <- data.frame()
inter_view_corr <- list()

for (f in mint_rdata_files) {
  d <- gsub(mint_rdata_ptrn, "", f)
  datasets_orig_names <- c(datasets_orig_names, d)
  message('Loading diablo results for dataset: ', d)
  f_path <- file.path(res_dir, f) 
  load(f_path, tmp_env <- new.env()) 
  
  if (length(tmp_env$minttea_results) == 0) next;
  
  # Extract objects
  module_variance_expl[[d]] <- 
    tmp_env$minttea_results$module_variance_expl %>% 
    bind_rows(.id = 'settings') 
  inter_view_corr[[d]] <- 
    tmp_env$minttea_results$module_inter_omic_cors %>% 
    bind_rows(.id = 'settings') 
  diablo_input[[d]] <- tmp_env$minttea_results$diablo_input 
  latent_vars[[d]] <- tmp_env$minttea_results$latent_vars
  feat_pairs[[d]] <- tmp_env$minttea_results$feat_pairs
  sens_analysis_modules <- 
    bind_rows(sens_analysis_modules, 
              tmp_env$minttea_results$sens_analysis_modules %>% 
                mutate(dataset = d)) 
  sens_analysis_runs[[d]] <- tmp_env$minttea_results$sens_analysis_runs 
  summary_aucs <- 
    bind_rows(summary_aucs, 
              tmp_env$minttea_results$summary_overall_aucs %>% 
                mutate(dataset = d)) 
  summary_module_aucs <- 
    bind_rows(summary_module_aucs, 
              tmp_env$minttea_results$summary_module_aucs %>% 
                mutate(dataset = d)) 
  datasets <- c(datasets, d)
  rm(tmp_env)
}
rm(d, f, f_path, mint_rdata_ptrn, mint_rdata_files)
```
### Misc.

```{r MISC_SETTINGS}
feature_type_color_map = 
  c("M" = "midnightblue", 
    "T" = "firebrick4", 
    "P" = "darkorange3", 
    "S" = "chartreuse4", 
    "All" = "grey30")
```

# 1. Overview of MintTea results per pipeline setting

```{r OVERVIEW}
modules_overview <- sens_analysis_modules %>%
  group_by(dataset, run_id, module) %>%
  summarise(n_feats = n(), 
            multi_view = n_distinct(substr(feature, 1, 1)) > 1,
            .groups = "drop") %>%
  left_join(summary_module_aucs %>% 
              filter(run == 'true') %>% 
              select(-run) %>%
              rename(run_id = setting) %>% 
              mutate(module = paste0('module', module_id)) %>%
              select(dataset,run_id,module,mean_module_auc),
            by = c('dataset', 'run_id', 'module')) %>%
  left_join(bind_rows(inter_view_corr, .id = 'dataset') %>%
              filter(run == 'true') %>% 
              select(-run) %>%
              rename(run_id = settings) %>% 
              mutate(module = paste0('module', module)) %>%
              select(dataset,run_id,module,avg_pears_corr),
            by = c('dataset', 'run_id', 'module')) 

all_settings_overview <- modules_overview %>%
  group_by(dataset, run_id) %>%
  summarise(n_modules = n(), 
            n_disease_associated_modules = 
              sum(multi_view & mean_module_auc > 0.7),
            max_module_auc = round(max(mean_module_auc),2),
            n_omic_correlation_modules = sum(multi_view & avg_pears_corr > 0.2),
            max_omic_corr = round(max(avg_pears_corr),2),
            n_interesting_modules = sum(multi_view & avg_pears_corr > 0.2 & mean_module_auc > 0.7),
            n_avg_feats = mean(n_feats), 
            n_feats_detail = paste0(n_feats, collapse = ','),
            .groups = "drop") %>%
  tidyr::separate(col = run_id, 
                  into = c('keep','des','nrep','nfol','ncom','edge'), 
                  remove = FALSE, sep = '//') %>%
  mutate(keep = factor(keep, levels = c('keep_5','keep_10','keep_15'))) %>%
  left_join(summary_aucs %>% 
              filter(run == 'true') %>% 
              rename(run_id = setting), 
            by = c('run_id', 'dataset')) 

# Print table
all_settings_overview %>%
  group_by(keep,des,nrep,nfol,ncom,edge) %>%
  summarise(Avg_number_of_modules = round(mean(n_modules),2), 
            Avg_module_size = round(mean(n_avg_feats),2),
            Avg_number_of_disease_modules = round(mean(n_disease_associated_modules),2),
            Max_ = max(n_disease_associated_modules),
            Min_ = min(n_disease_associated_modules),
            Avg_number_of_interesting_modules = round(mean(n_omic_correlation_modules),2),
            N_datasets = n(), .groups = "drop") %>%
  mutate(Avg_number_of_disease_modules = paste0(Avg_number_of_disease_modules, ' [', Min_, '-', Max_, ']')) %>%
  select(-Min_, -Max_) %>%
  mutate(keep = gsub('keep_','',keep)) %>%
  mutate(des = gsub('des_','',des)) %>%
  mutate(nrep = gsub('nrep_','',nrep)) %>%
  mutate(nfol = gsub('nfol_','',nfol)) %>%
  mutate(ncom = gsub('ncom_','',ncom)) %>%
  mutate(edge = gsub('edge_','',edge)) %>%
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  footnote(general = "These statistics are averaged over all datasets") %>%
  add_header_above(c("Settings" = 6, " " = 5))
```



```{r fig.width=8, fig.height=5}
# Do some settings consistently achieve better AUC?
all_settings_overview %>%
  tidyr::complete(dataset, run_id) %>%
  mutate(run_id2 = gsub('//', ' // ', run_id)) %>%
  mutate(run_id2 = gsub('// nfol', '//\nnfol', run_id2)) %>%
  ggplot(aes(y = dataset, x = run_id2, fill = mean_overall_rf_auc)) +
  geom_tile(color = 'black') +
  geom_text(aes(label = round(mean_overall_rf_auc,2)), size = 3) +
  xlab(NULL) +
  ylab(NULL) +
  theme_classic() +
  scale_x_discrete(position = 'top') +
  scale_fill_gradient(low = 'white', high = 'darkred',
                      name = 'Overall AUC',
                      na.value = 'lightgrey',
                      guide = guide_colorbar(frame.colour = "black")) +
  theme(axis.text.x.top = element_text(size = 8, angle = 60, hjust = -0.01, vjust = 0)) +
  theme(legend.position = "bottom") +
  theme(plot.margin = unit(c(1,95,1,1), 'points'))
```

```{r fig.width=20}
tmp <- all_settings_overview %>%
  select(dataset, run_id, n_interesting_modules, max_module_auc, max_omic_corr, n_omic_correlation_modules, n_feats_detail) %>%
  mutate(run_id = gsub('nrep_10//nfol_5//ncom_5','...',run_id)) %>%
  filter(max_module_auc>0.7 & !is.na(max_omic_corr) & max_omic_corr>0.2) 

tmp %>%
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```


# 2. Select pipeline settings

Pipeline settings per dataset:
We used a default setting, as listed below in the `selected_settings` variable.
If no disease associated module was found (auc's < 0.7), or if no module captured cross-omic correlations with an average above 0.3, then another parameter setting was used, as listed in supplementary table S4.

```{r}
selected_settings <- "keep_15//des_0.3//nrep_10//nfol_5//ncom_5//edge_0.8"
# Explore: tmp %>% group_by(run_id) %>% summarise(N = n())
# Datasets for which the selected setting doesn't yield non-trivial modules:
#  all_settings_overview %>% filter(run_id == selected_settings) %>% filter(n_interesting_modules == 0)

datasets_with_alternative_settings <- c(
  'uc_spain_nielsen_2014'='keep_15//des_0.5//nrep_10//nfol_5//ncom_5//edge_0.8',
  'crc_s3_s4_yachida_2019'='keep_10//des_0.3//nrep_10//nfol_5//ncom_5//edge_0.7',
  'esrd_wang_2020'='keep_15//des_0.3//nrep_10//nfol_5//ncom_5//edge_0.7',
  "sth_rubel_2020"='keep_10//des_0.5//nrep_10//nfol_5//ncom_5//edge_0.8'
)

rm(tmp)
```

```{r}
# Mark selected setting per dataset
all_settings_overview <- all_settings_overview %>%
  mutate(selected_setting = ifelse(
    dataset %in% names(datasets_with_alternative_settings),
    run_id == datasets_with_alternative_settings[dataset],
    run_id == selected_settings
  ))

pipeline_params_per_dataset <- 
  all_settings_overview$run_id[all_settings_overview$selected_setting]
names(pipeline_params_per_dataset) <- 
  all_settings_overview$dataset[all_settings_overview$selected_setting]

message("Downstream analysis is based on settings: ")
all_settings_overview %>%
  filter(selected_setting) %>%
  select(dataset, run_id) %>%
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) 
```

## Demonstrate sensitivty to parameters

Visualize what happens to a single module over various pipeline settings:

```{r fig.width=7, fig.height=7.5}
base_module <- list(d = 'cd_franzosa_2019', mod_id = 1)
p_sens23 <- plot_module_sensitivity_analysis(
  sens_analysis_modules, 
  latent_vars, 
  base_module, 
  selected_settings)
plot_grid(
  # p_sens1 + theme(legend.position = 'none'), 
  p_sens23$p1, 
  p_sens23$p2 + theme(axis.text.x = element_blank()), 
  ncol = 1, 
  rel_heights = c(11,2), 
  align = 'v'
  )
rm(base_module, p_sens23)
```



## Narrow results to the selected settings

```{r}
# Free unneeded memory (settings other than the one chosen)
# Note - different lists are filtered differently according to object format/structure...
narrow_res_df_list <- function(lst, pipeline_params_per_dataset) {
  tmp <- lapply(names(lst), 
                function(d) 
                  lst[[d]] %>% 
                  filter(settings == pipeline_params_per_dataset[d]))
  names(tmp) <- names(lst)
  return(tmp)
}

module_variance_expl <- 
  narrow_res_df_list(module_variance_expl, pipeline_params_per_dataset)
inter_view_corr <- 
  narrow_res_df_list(inter_view_corr, pipeline_params_per_dataset)

tmp <- lapply(names(latent_vars), 
              function(d) 
                latent_vars[[d]][[pipeline_params_per_dataset[d]]])
names(tmp) <- names(latent_vars)
latent_vars <- tmp

modules_overview <- modules_overview %>%
  filter(run_id == pipeline_params_per_dataset[dataset])
sens_analysis_modules <- sens_analysis_modules %>% 
  filter(run_id == pipeline_params_per_dataset[dataset])
summary_module_aucs <- summary_module_aucs %>% 
  filter(setting == pipeline_params_per_dataset[dataset])
summary_aucs <- summary_aucs %>% 
  filter(setting == pipeline_params_per_dataset[dataset])

# For faster filtering 
tmp <- lapply(
  names(feat_pairs), 
  function(d) {
    # Split param string
    tmp2 <- strsplit(strsplit(pipeline_params_per_dataset[d], "//")[[1]], '_')
    selected_settings_l <- lapply(tmp2, function(x) as.numeric(x[2]))
    names(selected_settings_l) <- sapply(tmp2, function(x) x[1])
    # Use single params for faster filtering
    feat_pairs[[d]] %>% 
       filter(param_keepX == selected_settings_l$keep) %>%
       filter(param_diablo_design == selected_settings_l$des) %>%
       filter(param_n_repeats == selected_settings_l$nrep) %>%
       filter(param_n_folds == selected_settings_l$nfol) %>%
       filter(param_ncomp == selected_settings_l$ncom) }
)
names(tmp) <- names(feat_pairs) 
feat_pairs <- tmp
rm(tmp)
```

## Change to "pretty" dataset names

```{r}
new_dataset_names <-c(
  "cd_franzosa_2019"="CD (Franzosa, 2019)",
  "cirrhosis_qin_2014"="Cirrhosis (Qin, 2014)",
  "crc_feng_2015"="CRC (Feng, 2015)",
  "crc_s3_s4_yachida_2019"="CRC (Yachida, 2019)",
  "crc_yu_2015"="CRC (Yu, 2015)",
  "esrd_wang_2020"="ESRD (Wang, 2020)",
  "metacardis_1_8"="MS (MetaCardis)",
  "metacardis_3_8"="T2D (MetaCardis)",
  "sth_rubel_2020"="STH (Rubel, 2020)",
  "uc_franzosa_2019"="UC (Franzosa, 2019)",
  "uc_spain_nielsen_2014"="UC (Nielsen, 2014)"
  )

sens_analysis_modules$dataset <- new_dataset_names[sens_analysis_modules$dataset]
modules_overview$dataset <- new_dataset_names[modules_overview$dataset]
summary_aucs$dataset <- new_dataset_names[summary_aucs$dataset]
summary_module_aucs$dataset <- new_dataset_names[summary_module_aucs$dataset]
rf_results$dataset <- new_dataset_names[rf_results$dataset]
all_clusters$dataset <- new_dataset_names[all_clusters$dataset]
rf_feat_imp_sum$dataset <- new_dataset_names[rf_feat_imp_sum$dataset]
datasets <- new_dataset_names[datasets]
names(feat_pairs) <- new_dataset_names[names(feat_pairs)]
names(diablo_input) <- new_dataset_names[names(diablo_input)]
names(inter_view_corr) <- new_dataset_names[names(inter_view_corr)]
names(latent_vars) <- new_dataset_names[names(latent_vars)]
names(module_variance_expl) <- new_dataset_names[names(module_variance_expl)]
names(sens_analysis_runs) <- new_dataset_names[names(sens_analysis_runs)]
names(pipeline_params_per_dataset) <- new_dataset_names[names(pipeline_params_per_dataset)]
```


```{r}
# Save module sizes
module_sizes <- sens_analysis_modules %>% 
  group_by(dataset, run_id, module) %>% 
  summarize(module_size = n(), .groups = 'drop') 

summary_aucs <- summary_aucs %>%
  left_join(module_sizes %>%
              group_by(dataset) %>%
              summarize(n_modules = n(), 
                        n_features = sum(module_size), 
                        .groups = 'drop'),
            by = 'dataset')
```

# 4. Module pheatmaps

```{r fig.height=5, fig.width=8}
only_features_in_final_modules <- TRUE

for(curr_dataset in datasets) {
  
  # Only plot the features that were included in components
  # (To make plot readable)
  if (only_features_in_final_modules) {
    feats_to_plot <- sens_analysis_modules %>%
      filter(dataset == curr_dataset) %>%
      pull(feature) %>%
      unique()
  } else {
    feats_to_plot <- feat_pairs[[curr_dataset]] %>%
      group_by(feature.x) %>%
      summarise(N = n(), min_dist = min(dist)) %>%
      filter(min_dist < 0.5) %>%
      pull(feature.x)
  }
  
  # Mark final components to highlight in pheatmaps
  final_modules <- sens_analysis_modules %>%
    filter(dataset == curr_dataset) %>%
    select(feature, module) %>%
    rename(Module = module) %>%
    mutate(Module = gsub('module','',Module)) %>%
    full_join(data.frame(feature = feats_to_plot), by = 'feature') %>%
    tibble::column_to_rownames('feature')
  
  # Get pairwise info about features
  feat_pairs_mat <- feat_pairs[[curr_dataset]] %>%
    filter((feature.x %in% feats_to_plot) & 
             (feature.y %in% feats_to_plot)) %>%
    mutate(dist = 1 - (N/(param_n_repeats*param_n_folds))) %>%
    # Convert to a wide matrix
    tidyr::pivot_wider(id_cols = feature.x, 
                       names_from = feature.y, 
                       values_from = dist, 
                       values_fill = 1) %>%
    tibble::column_to_rownames(var = "feature.x") %>%
    as.matrix()
  
  # Reorder to make it a symmetric distance matrix
  feat_pairs_mat <- feat_pairs_mat[,rownames(feat_pairs_mat)]
  diag(feat_pairs_mat) <- 0
  
  # Colors for component annotation:
  ann_colors <- list(
    Module = brewer.pal(n = 12, name = "Paired") %>% 
      sample(size = n_distinct(na.omit(final_modules$Module)))
  )
  names(ann_colors$Module) <- unique(na.omit(final_modules$Module))
  
  # Plot distance matrix directly
  ph1 <- pheatmap(feat_pairs_mat, 
                 color = colorRampPalette(rev(brewer.pal(n = 7, name = "YlGnBu")))(50),
                 border_color = 'grey70',
                 show_rownames = F, 
                 show_colnames = T,
                 treeheight_row = 18,
                 treeheight_col = 22, 
                 annotation_row = final_modules,
                 annotation_colors = ann_colors, 
                 fontsize_col = 5,
                 fontsize = 8,
                 silent = T,
                 annotation_legend=F,
                 main = paste('Module-cooccurence matrix,\nDataset:',curr_dataset))
  
  # For comparison - also plot correlation matrix
  tmp <- bind_cols(lapply(diablo_input[[curr_dataset]]$X, function(x) data.frame(x) %>% select(any_of(feats_to_plot))))
  cor_mat <- abs(cor(tmp, method = "spearman"))
  
  # Reorder correlation matrix to match the plot above
  new_order <- colnames(feat_pairs_mat)[ph1$tree_row$order]
  cor_mat <- cor_mat[new_order, new_order]
  
  # Plot correlation matrix
  ph2 <- pheatmap(cor_mat,
                 color = colorRampPalette(brewer.pal(n = 7, name = "YlGnBu"))(50),
                 border_color = 'grey70',
                 show_rownames = F, 
                 show_colnames = T,
                 annotation_row = final_modules,
                 annotation_colors = ann_colors, 
                 fontsize_col = 5,
                 cluster_cols = F,
                 cluster_rows = F,
                 fontsize = 8,
                 silent = T,
                 main = paste('Feature correlation (abs) matrix,\nDataset:',curr_dataset,'\n'))
  
  print(plot_grid(ph1$gtable, ph2$gtable, align = 'h',axis = 'tb', 
                  rel_widths = c(7,7.3)))
  
  # Save correlations for later use
  cors_with_p <- rcorr(as.matrix(tmp), type = "spearman")
  cors_melted <- data.frame(cors_with_p$r) %>%
    tibble::rownames_to_column('feature.x') %>%
    tidyr::pivot_longer(cols = -feature.x, names_to = 'feature.y', values_to = 'spearman_r')
  cors_p_melted <- data.frame(cors_with_p$P) %>%
    tibble::rownames_to_column('feature.x') %>%
    tidyr::pivot_longer(cols = -feature.x, names_to = 'feature.y', values_to = 'spearman_p') %>%
    mutate(spearman_fdr = p.adjust(spearman_p, method = 'fdr')) 
  cors_melted <- cors_melted %>%
    left_join(cors_p_melted, by = c("feature.x", "feature.y"))
  feat_pairs[[curr_dataset]] <- feat_pairs[[curr_dataset]] %>%
    left_join(cors_melted, by = c("feature.x", "feature.y"))
}

rm(curr_dataset, feats_to_plot, ph1, ph2, feat_pairs_mat, final_modules, tmp, cor_mat, new_order, only_features_in_final_modules, cors_p_melted)
```

# 5. Module evaluations

## 5.1. Variance explained by PC1 for components vs. shuffled

```{r fig.height=2, fig.width=6.5}
for(curr_dataset in datasets) {
  tmp <- module_variance_expl[[curr_dataset]] %>%
    mutate(module = paste0('Module', module)) %>%
    left_join(module_sizes %>% 
                mutate(module = gsub('m','M',module)) %>% 
                filter(dataset == curr_dataset), 
              by = 'module') %>%
    mutate(module = paste0(module, ' (N=', module_size, ')'))
  
  p <- ggplot(tmp %>% 
                filter(run != 'true'), 
              aes(x = var_explained_pc1)) +
    geom_histogram(color = 'black', fill = 'lightgrey', bins = 30) +
    geom_vline(data = tmp %>% filter(run == 'true'), 
               aes(xintercept = var_explained_pc1), 
               color = 'darkred', linewidth = 1.5, alpha = 0.5) +
    scale_y_continuous(expand = c(0,0)) +
    theme_bw() +
    ggtitle('Histograms of variance explained by PC1') +
    labs(subtitle = paste('Dataset:', curr_dataset)) +
    ylab('Count') +
    xlab('Variance explained by PC1') +
    facet_wrap(~ module, nrow = 1)
  
  print(p)
}
rm(tmp, curr_dataset, p)
```

## 5.2. Average inter-view correlations

```{r fig.height=2.5, fig.width=6.5}
module_cross_view_corrs <- data.frame()

for(d in datasets) {
  module_cross_view_corrs <- 
    bind_rows(module_cross_view_corrs, 
              inter_view_corr[[d]] %>% mutate(dataset = d))
  
  tmp <- inter_view_corr[[d]] %>%
    mutate(module = paste0('module', module)) %>%
    left_join(module_sizes %>% 
                select(-run_id) %>% 
                filter(dataset == d), 
              by = 'module') %>%
    mutate(module = paste0(module, ' (N=', module_size, ')')) %>%
    filter(!is.na(avg_pears_corr))
  
  if (nrow(tmp) == 0) next;
    
  p <- ggplot(tmp %>% filter(run != 'true'), aes(x = avg_pears_corr)) +
    geom_histogram(color = 'black', fill = 'lightgrey', bins = 30) +
    geom_vline(data = tmp %>% filter(run == 'true'), 
               aes(xintercept = avg_pears_corr), 
               color = 'darkred', 
               linewidth = 1.5, 
               alpha = 0.5) +
    scale_y_continuous(expand = c(0,0)) +
    theme_bw() +
    ggtitle('Histograms of average cross-view correlations') +
    labs(subtitle = paste('Dataset:', d)) +
    ylab('Count') +
    xlab('Correlation') +
    facet_wrap(~ module, nrow = 1)
  
  print(p)
}
rm(tmp, d, p)
```

## TODO: 5.3. Overall AUC, components vs. shuffled

```{r fig.height=2.6, fig.width=7}
plot_overall_summary_module_aucs(rf_results, summary_aucs, datasets)
```

## 5.4. Module summary plots

Panels, left to right:  

* N features in each module  
* Cross-view correlations  
* Module AUC  

```{r fig.height=7, fig.width=6}
module_stats_summary <- 
  plot_module_stats(
    sens_analysis_modules, 
    module_cross_view_corrs, 
    summary_module_aucs %>% 
      left_join(
        rf_results %>% select(dataset, mean_auc, sd_auc) %>% rename(mean_auc_rf = mean_auc, sd_auc_rf = sd_auc), 
        by = 'dataset'
        ), 
    feature_type_color_map,
    dataset_order = datasets,
    show_rf = FALSE)

module_stats_summary <- module_stats_summary %>%
  filter(dataset %in% datasets) %>%
  left_join(summary_aucs %>%
              filter(run == 'true') %>%
              select(dataset, mean_overall_rf_auc, mean_overall_lm_auc),
            by = 'dataset') 

# Use only modules that have >1 feature types and >=3 features (as already filtered in the table above)
sens_analysis_modules <- sens_analysis_modules %>%
  mutate(module = as.numeric(gsub('module','',module))) %>%
  inner_join(module_stats_summary, by = c('dataset','module')) 
```

## 5.5. Module general statistics

```{r results='hold'}
message('Modules were identified for ', 
        n_distinct(module_stats_summary$dataset), 
        ' datasets of ', length(datasets), ' analyzed')

message(min(table(module_stats_summary$dataset)), '-',
        max(table(module_stats_summary$dataset)), 
        ' modules were identified per dataset, average: ',
        round(mean(table(module_stats_summary$dataset)),2))

message('Module sizes ranged between ',
        min(module_stats_summary$n_features), ' to ',
        max(module_stats_summary$n_features), 
        ', average: ',
        round(mean(module_stats_summary$n_features), 2))

tmp_signif_comps_per_dataset <- module_stats_summary %>%
  mutate(dataset = factor(dataset)) %>%
  filter(mean_module_auc > 0.7 & mean_module_auc > mean_shuf_auc) %>%
  group_by(dataset, .drop = FALSE) %>%
  summarize(N = n())
  
message(min(tmp_signif_comps_per_dataset$N), '-',
        max(tmp_signif_comps_per_dataset$N), 
        ' modules were also highly predictive, average: ',
        round(mean(tmp_signif_comps_per_dataset$N), 2))

rm(tmp_signif_comps_per_dataset)
```

# 6. Detailed modules - organize details

## Function for making prettier feature names

Fix some distorted feature names:

```{r}
feat_name_fixes <- c(
  "[P] superpathway of unsaturated fatty acids biosynthesis (_E. coli_)" = "[P] SP of unsaturated fatty acids biosynthesis (E. coli)",
  "[T] X_Ruminococcus__torques" = "[T] Ruminococcus_torques",
  "[T]  Clostridium  symbiosum" = "[T] Clostridium_symbiosum",
  "[M] C18.neg_Cluster_0079..undecanedionate"="[M] Undecanedionate",
  "[M] C18.neg_Cluster_0361..eicosatrienoic.acid"="[M] Eicosatrienoic acid",
  "[M] C18.neg_Cluster_0506..adrenic.acid"="[M] Adrenic acid",
  "[M] C18.neg_Cluster_0901..7.ketodeoxycholate"="[M] 7-ketodeoxycholate",
  "[M] HILIC.neg_Cluster_0003..propionate" = "[M] Propionate",  
  "[M] HILIC.neg_Cluster_0013..butyrate...isobutytare."  = "[M] Butyrate/isobutytare",               
  "[M] HILIC.neg_Cluster_0220..3.methyladipate.pimelate" = "[M] 3-methyladipate / pimelate",
  "[M] HILIC.neg_Cluster_0331..sorbitol" = "[M] Sorbitol",                                             
  "[M] HILIC.neg_Cluster_0441..sebacate" = "[M] Sebacate",
  "[M] HILIC.pos_Cluster_2093..urobilin."="[M] Urobilin (I)",
  "[M] C18.neg_Cluster_2021..urobilin"="[M] Urobilin (II)",
  "[M] HILIC.pos_Cluster_0384..N.acetylglutamic.acid"="[M] N-acetylglutamic acid (I)",
  "[M] C8.pos_Cluster_1004..C16.0.ceramide..d18.1."="[M] C16:0 ceramide",
  "[M] HILIC.pos_Cluster_0521..L.1.2.3.4.tetrahydro.beta.carboline.3.carboxylic.acid."="[M] THBC-CA",
  "[M] HILIC.pos_Cluster_0184..pyridoxamine"="[M] Pyridoxamine (I)",
  "[M] HILIC.pos_Cluster_0268..pyridoxamine"="[M] Pyridoxamine (II)",
  "[M] C18.neg_Cluster_0486..carnosol"="[M] Carnosol",
  "[M] HILIC.neg_Cluster_0156..caprylic.acid"="[M] Caprylic acid",
  "[M] HILIC.neg_Cluster_1360..chenodeoxycholate.deoxycholate."="[M] Chenodeoxycholate / deoxycholate",
  "[M] HILIC.pos_Cluster_0062..nicotinic.acid"="[M] Nicotinic acid (I)",
  "[M] HILIC.neg_Cluster_0082..nicotinate"="[M] Nicotinic acid (II)",
  "[M] HILIC.pos_Cluster_0495..N.acetylglutamic.acid"="[M] N-acetylglutamic acid (II)",
  "[M] HILIC.pos_Cluster_0524..N.acetyl.L.arginine"="[M] N-acetyl-L-arginine",
  "[M] HILIC.pos_Cluster_0540..pantothenate"="[M] Pantothenate",
  "[M] HILIC.pos_Cluster_0728..2.deoxyadenosine"="[M] 2-deoxyadenosine",
  "[M] C8.pos_Cluster_0277..stearoyl.ethanolamide" = "[M] Stearoyl ethanolamide",
  "[M] HILIC.neg_Cluster_0030..methylbutyric.aid...valeric...isovaleric."="[M] Methylbutyric acid/valeric/isovaleric acid",
  "[M] HILIC.neg_Cluster_0133..4.nitrophenol" = "[M] 4-nitrophenol",
  "[M] HILIC.neg_Cluster_0181..hydrocinnamic.acid"= "[M] Hydrocinnamic acid",
  "[M] HILIC.pos_Cluster_1374..C14.carnitine" = "[M] C14 carnitine"
)

  # 'T__Oscillibacter.sp..57_20'='T__Oscillibacter_sp_57_20',
  # 'T__X_Ruminococcus__torques'='T__Ruminococcus_torques',
  # 'M__HILIC.neg_Cluster_0003..propionate'='M__Propionic.acid',
  # 'T__.Ruminococcus..gnavus'='T__Ruminococcus_gnavus',
  # 'T__.Eubacterium..rectale'='T__Eubacterium_rectale',
  # 'T__.Clostridium..symbiosum'='T__Clostridium_symbiosum',
  # 'T__.Clostridium..innocuum'='T__Clostridium_innocuum',
  # 'M__HILIC.pos_Cluster_0100..ornithine'='M__Ornithine',
  # 'M__HILIC.pos_Cluster_0090..creatine'='M__Creatine',
  # 'M__HILIC.pos_Cluster_0099..asparagine'='M__Asparagine',
  # 'M__HILIC.neg_Cluster_0112..asparagine'='M__Asparagine',
  # 'M__C00294_Inosine'='M__Inosine',
  # 'M__HILIC.neg_Cluster_0824..inosine'='M__Inosine',
  # 'M__HILIC.neg_Cluster_0013..butyrate...isobutytare.'=
  #   'M__Butyrate/Isobutyrate',
  # 'M__HILIC.pos_Cluster_2093..urobilin.'='M__Urobilin',
  # 'M__C18.neg_Cluster_2021..urobilin'='M__Urobilin',
  # 'M__HILIC.neg_Cluster_0220..3.methyladipate.pimelate'=
  #   'M__3-methyladipate-pimelate',
  # "[P] queuosine biosynthesis I (<i>de novo</i>)"=
  #   "[P] queuosine biosynthesis I (de novo)",
  # "[M] Benzaldehyde..3.chloro.5.methoxy.4...4.methylphenyl.methoxy.." = "[M] 3-chloro-5-methoxy-4-[(4-methylphenyl)methoxy]benzaldehyde",
  # "[M] ....Menthone" = "[M] Menthone",
  # "[P] <i>S</i>-adenosyl-L-methionine salvage I"=
  #   "[P] S-adenosyl-L-methionine salvage I",
  # "[G] hydrogenase expression/formation protein HypD"="[G] HypD",
  # "[G] citrate lyase subunit gamma (acyl carrier protein)"="[G] citD",
  # "[G] nondiscriminating aspartyl-tRNA synthetase"=
  #   "[G] aspC, aspS",
  # "[G] oligogalacturonide transport system substrate-binding protein"=
  #   "[G] togB",
  # "[G] solute carrier family 13 (sodium-dependent dicarboxylate transporter), member 2/3/5"=
  #   "[G] SLC13A2_3_5",
  # "[G] [Deprecated KO] glucose PTS system EIICBA or EIICB component"="[G] ptsG",
  # "[G] uroporphyrinogen III methyltransferase / synthase"="[G] cobA-hemD",
  # "[G] electron transfer flavoprotein alpha subunit"="[G] fixB, etfA" ,
  # "[G] N-acetylglucosamine PTS system EIIB component"="[G] nagEb",
  # "[G] phosphonate transport system permease protein"="[G] phnE",
  # "[G] oxaloacetate decarboxylase (Na+ extruding) subunit alpha"="[G] oadA",
  # "[P] UDP-<i>N</i>-acetylmuramoyl-pentapeptide biosynthesis III (<i>meso</i>-diaminopimelate containing)"=
  #   "[P] UDP-MurNAc-pentapeptide biosynthesis III",
  # "[P] chorismate biosynthesis from 3-dehydroquinate"=
  #   "[P] chorismate biosynthesis from DHQ",
  # "[M] C18.neg_Cluster_0361..eicosatrienoic.acid"=
  #   "[M] eicosatrienoic acid",
  # "[P] superpathway of pyrimidine deoxyribonucleosides degradation"=
  #   "[P] superpathway of PY deoxyribonucleosides degradation",
  # "[G] formylmethanofuran--tetrahydromethanopterin N-formyltransferase"=
  #   "[G] formyltransferase",
  # "[G] tRNA (guanine26-N2/guanine27-N2)-dimethyltransferase"="[G] TRMT1",
  # "[G] WhiB family transcriptional regulator, redox-sensing transcriptional regulator"=
  #   "[G] whiB1_2_3_4",
  # "[P] superpathway of geranylgeranyldiphosphate biosynthesis I (via mevalonate)"=
  #   "[P] SP of GGPP biosynthesis I (via mevalonate)",
  # "[P] superpathway of geranylgeranyl diphosphate biosynthesis II (via MEP)"=
  #   "[P] SP of GGPP biosynthesis II (via MEP)",
  # "[P] superpathway of L-lysine, L-threonine and L-methionine biosynthesis I"=
  #   "[P] SP of Lys, Thr and Met biosynthesis I",
  # "[P] hexitol fermentation to lactate, formate, ethanol and acetate"=
  #   "[P] hexitol fermentation",
  # "[M] 1.7.Di.3.ethylphenyl..2.2.4.4.6.6.hexamethyl.1.3.5.7.tetraoxa.2.4.6.trisilaheptane"=
  #   "[M] PubChem_91742720",
  # "[P] 3-phenylpropanoate and 3-(3-hydroxyphenyl)propanoate degradation to 2-hydroxypentadienoate"="[P] HCAMHPDEG-PWY",
  # "[G] uroporphyrin-III C-methyltransferase / precorrin-2 dehydrogenase / sirohydrochlorin ferrochelatase"=
  #   "[G] cysG",
  # "[P] peptidoglycan biosynthesis I (_meso_-diaminopimelate containing)"="[P] peptidoglycan biosynthesis I",
  # "[P] peptidoglycan maturation (_meso_-diaminopimelate containing)"="[P] peptidoglycan maturation",
  # "[P] superpathway of pyrimidine ribonucleosides degradation" = "[P] SP of pyrimidine ribonucleosides degradation",
  # "[P] superpathway of fatty acid biosynthesis initiation" = "[P] SP of fatty acid biosynthesis initiation",
  # "[P] sucrose degradation IV (sucrose phosphorylase)" = "[P] sucrose degradation IV (phosphorylase)",
  # "[P] palmitate biosynthesis I (type I fatty acid synthase)" = "[P] palmitate biosynthesis I",
  # "[P] glucose fermentation to lactic acid (Bifidobacteria)" = "[P] glucose fermentation to lactate (Bifidobacteria)",
  # "[P] glucose and glucose-1-phosphate degradation" = "[P] glucose/glucose-1-phosphate degradation",
  # "[G] shikimate kinase / 3-dehydroquinate synthase" = "[G] aroKB",
  # "[G] non-reducing end beta-L-arabinofuranosidase" = "[G] hypBA1",
  # "[P] protocatechuate degradation II (ortho-cleavage pathway)" = "[P] protocatechuate degradation II"
  # 
```

```{r}
get_pretty_names <- function(feat_names, feat_name_fixes, remove_cluster_info = F, string_wrap = NA) {
  # Patch for taxonomy
  new_feat_names <- gsub('T__([a-zA-Z]*)\\.([a-zA-Z0-9_]*)$', 'T__\\1_\\2', feat_names)
  
  # Remove cluster identifiers?
  if (remove_cluster_info) new_feat_names <- gsub('_Cluster[0-9]+$', '', new_feat_names)
  
  # Get description instead of codes
  feat_types <- unname(sapply(new_feat_names, substr, 0, 1))
  new_feat_names <- paste0('[', feat_types, '] ', get_feature_descriptions(new_feat_names))
  
  new_feat_names <- gsub('  ',' ',new_feat_names)
  
  # Manual fixes
  new_feat_names <- sapply(
    new_feat_names, 
    function(x, feat_name_fixes) {
      ifelse(x %in% names(feat_name_fixes), feat_name_fixes[x], x)
      }, 
    feat_name_fixes
    ) %>% unname()
  
  # Wrap string for some plots
  if (!is.na(string_wrap)) new_feat_names <- strwrap(new_feat_names, width = string_wrap)
  
  return(new_feat_names)
}
```


## Simple U-tests to indicate increase/decrease in disease

```{r}
all_utests <- get_u_tests(sens_analysis_modules, diablo_input)
sens_analysis_modules <- sens_analysis_modules %>%
  left_join(all_utests %>% 
              select(dataset, feature, increased_in), 
            by = c('dataset','feature')) %>%
  mutate(description = get_pretty_names(feature, feat_name_fixes))
```


# 7. Supplementary tables S4, S5, S7

## Save modules overview - S4

```{r}
module_stats_summary %>%
  mutate(mean_shuf_auc = round(mean_shuf_auc, 3)) %>%
  mutate(sd_shuf_auc = round(sd_shuf_auc, 3)) %>%
  mutate(mean_module_auc = round(mean_module_auc, 3)) %>%
  mutate(mean_overall_rf_auc = round(mean_overall_rf_auc, 3)) %>%
  select(-mean_overall_lm_auc) %>%
  mutate(`Pipeline settings` = pipeline_params_per_dataset[dataset]) %>%
  relocate(dataset, module, n_features) %>%
  rename(Dataset = dataset) %>%
  rename(`Module size` = n_features) %>%
  rename(Module = module) %>%
  rename(`Module AUC` = mean_module_auc) %>%
  rename(`Average shuffled module AUC (Null model)` = mean_shuf_auc) %>%
  rename(`SD shuffled module AUC (Null model)` = sd_shuf_auc) %>%
  rename(`Average inter-view correlations` = avg_pears_corr) %>%
  rename(`Average shuffled inter-view correlations (Null model)` = mean_shuf_corr) %>%
  rename(`SD shuffled inter-view correlations (Null model)` = sd_shuf_corr) %>%
  rename(`All modules AUC (Random Forest)` = mean_overall_rf_auc) %>%
  write_csv("docs/Table_S4.csv")
```

## Save detailed modules - S5

```{r}
sens_analysis_modules %>%
  select(dataset, module, feature, description, increased_in) %>%
  rename(Dataset = dataset) %>%
  rename(Module = module) %>%
  rename(Feature = feature) %>%
  rename(`Feature description` = description) %>%
  rename(`Increased in?` = increased_in) %>%
  write_csv("docs/Table_S5.csv")
```

## Save clusters info - S7

Only non-singleton clusters are listed, and only if these clusters were selected by feature selection or by MintTea

```{r}
all_clusters %>%
  filter(!singleton) %>%
  # Only features relevant to a module
  filter(feature %in% sens_analysis_modules$feature) %>%
  select(dataset, feature_orig, cluster, feature) %>%
  arrange(dataset, cluster) %>%
  rename(Dataset = dataset) %>%
  rename(`Original feature name` = feature_orig) %>%
  rename(`Cluster representative (randomly selected)` = feature) %>%
  rename(`Cluster ID` = cluster) %>%
  write_csv("docs/Table_S7.csv")
```

# 8. Features reoccuring in multiple modules

## Which features are most common within modules?

```{r fig.height=7, fig.width=8}
sens_analysis_modules2 <- sens_analysis_modules %>%
  mutate(original_feature = feature) %>%
  mutate(feature = description)

common_feats <- sens_analysis_modules2 %>%
  group_by(feature) %>%
  summarise(N = n(), N_unique_datasets = n_distinct(dataset)) %>%
  filter(N > 3) %>%
  pull(feature)

all_plots <- list()

for (fs in common_feats) {
  tmp <- sens_analysis_modules2 %>%
    # Get all modules that include this feature
    group_by(dataset, module) %>%
    filter(sum(feature == fs) > 0) %>%
    ungroup() %>%
    # Mark feature type
    mutate(feat_type = substr(feature, 2, 2)) %>%
    # Mark modules associated with disease
    mutate(signif_module = (mean_module_auc > 0.7)) 
  
  # Make selected feature appear at the top
  all_feats <- sort(unique(tmp$feature))
  all_feats <- c(all_feats[all_feats != fs], fs)
  tmp <- tmp %>% mutate(feature = factor(description, levels = all_feats))
  
  # For adding lines and further formatting
  tmp <- tmp %>% 
    arrange(feature) %>%
    group_by(dataset, module) %>% 
    mutate(ymin = first(feature), ymax = last(feature)) %>% 
    ungroup() 

  fs_highlight_y <- which(sort(unique(tmp$feature)) == fs)
  
  p <- ggplot(tmp, aes(x = dataset)) +
    geom_point(aes(y = feature, fill = signif_module, shape = increased_in), 
               size = 4, color = 'white') +
    geom_linerange(aes(ymin = ymin, ymax = ymax), color = 'darkorange4') +
    annotate("rect", 
             ymin = fs_highlight_y-0.5, 
             ymax = fs_highlight_y+0.5, 
             xmin = -Inf, xmax = Inf, 
             alpha = .15, fill = "green4") +
    geom_point(aes(y = feature, fill = signif_module, shape = increased_in), 
               size = 4, color = 'white') +
    scale_shape_manual(values = c('disease' = 24, 'healthy' = 25, 'non-significant' = 21)) +
    scale_x_discrete(position = 'top') +
    scale_fill_manual(values = c('TRUE' = 'darkorange4', 'FALSE' = 'darkorange3')) +
    theme_classic() +
    ggtitle(fs) +
    xlab(NULL) +
    ylab(NULL) +
    theme(legend.position = 'none') +
    theme(axis.text.x.top = element_text(angle = 60, size = 9, hjust = 0)) +
    theme(axis.text.y = element_text(size = 9)) +
    theme(plot.margin = unit(c(10,95,1,1), 'points'))
  
  print(p)
  all_plots[[fs]] <- p
}

rm(common_feats, fs, tmp, p, fs_highlight_y)
```

```{r fig.width=8, fig.height=6.8}
# all_plots$T__Bacteroides_uniformis
```

# 9. Overlapping components

## Overlaps matrix

Components within the same dataset are not compared (not expected to overlap).

```{r COMP_INTERSECTIONS, eval=F}
module_intersections <- module_stats_summary %>% 
  tidyr::expand(tidyr::nesting(dataset, module), tidyr::nesting(dataset, module), .name_repair = "minimal") %>%
  rename(ds_left = 1, module_left = 2, ds_right = 3, module_right = 4) %>%
  filter(ds_left > ds_right)

tmp <- apply(
  module_intersections, 1, 
  function(r) { # r = module_intersections %>% head(1) %>% unlist()
    ds_left = unname(r['ds_left'])
    module_left = unname(r['module_left'])
    ds_right = unname(r['ds_right'])
    module_right = unname(r['module_right'])
    
    # Lists of all features available in each dataset
    feats_left <- sens_analysis_modules %>%
      filter(dataset == ds_left) %>% 
      filter(module == paste0('module', module_left)) %>% 
      pull(feature)
    
    feats_right <- sens_analysis_modules %>%
      filter(dataset == ds_right) %>% 
      filter(module == paste0('module', module_right)) %>% 
      pull(feature)
    
    # Quick fixes
    feats_left <- ifelse(grepl('^T__', feats_left), gsub('\\.','_',feats_left), feats_left)
    feats_right <- ifelse(grepl('^T__', feats_right), gsub('\\.','_',feats_right), feats_right)
    
    # All features shared between datasets, regardless of modules
    all_left <- diablo_input[[ds_left]]$X %>% 
                                sapply(colnames) %>% 
                                unlist() %>% 
                                unname()
    
    all_right <- diablo_input[[ds_right]]$X %>% 
                                sapply(colnames) %>% 
                                unlist() %>% 
                                unname()
    
    # Quick name fixes
    all_left <- ifelse(all_left %in% names(feat_name_fixes), feat_name_fixes[all_left], all_left)
    all_right <- ifelse(all_right %in% names(feat_name_fixes), feat_name_fixes[all_right], all_right)
    all_left <- gsub('T__([a-zA-Z]*)\\.([a-zA-Z0-9_]*)$', 'T__\\1_\\2', all_left)
    all_right <- gsub('T__([a-zA-Z]*)\\.([a-zA-Z0-9_]*)$', 'T__\\1_\\2', all_right)
    all_left <- gsub('_Cluster[0-9]+$', '', all_left)
    all_right <- gsub('_Cluster[0-9]+$', '', all_right)
    
    # Get shared features
    shared_feats <- intersect(all_left, all_right)
    feats_left2 <- intersect(feats_left, shared_feats)
    feats_right2 <- intersect(feats_right, shared_feats)
    
    # Compute Fisher's exact test
    cont_table <- matrix(c(length(intersect(feats_left2, feats_right2)), 
                           length(setdiff(feats_right2, feats_left2)), 
                           length(setdiff(feats_left2, feats_right2)), 
                           length(setdiff(shared_feats, union(feats_left2, feats_right2)))), 
                         nrow = 2,
                         dimnames = list(Comp_left = c("In", "Out"),
                                         Comp_right = c("In", "Out")))
    fshr <- fisher.test(cont_table, alternative = "greater")
  
    return(c('n_intersection' = cont_table["In","In"], 
             'n_left_only__in_other_dataset' = cont_table["In","Out"],
             'n_right_only__in_other_dataset' = cont_table["Out","In"],
             'n_left_only__not_in_other_dataset' = length(setdiff(feats_left, feats_left2)),
             'n_right_only__not_in_other_dataset' = length(setdiff(feats_right, feats_right2)),
             'fisher_p' = fshr$p.value,
             'odds_ratio' = unname(fshr$estimate)))
  }) %>% 
  t() %>%
  data.frame() 

module_intersections <- bind_cols(module_intersections, tmp) 
module_intersections <- module_intersections %>% 
  mutate(fisher_fdr = p.adjust(fisher_p, method = 'fdr'))

# Print
# module_intersections %>%
#   arrange(fisher_fdr) %>%
#   select(-fisher_p) %>%
#   kbl() %>%
#   kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

rm(tmp)
```

## Supplementary Table S6

Only component pairs with at least 3 common features and FDR < 0.1.

```{r eval=F}
module_intersections %>%
  filter(n_intersection >= 3 & fisher_fdr <= 0.1) %>%
  select(-fisher_p) %>%
  mutate(`Module - left` = paste(module_left,'/',ds_left)) %>%
  mutate(`Module - right` = paste(module_right,'/',ds_right)) %>%
  select(-ds_left, -ds_right, -module_left, -module_right) %>%
  rename(`N features in intersection` = n_intersection) %>%
  rename(`N features in left component only` = n_left_only__in_other_dataset) %>%
  rename(`N features in right component only` = n_right_only__in_other_dataset) %>%
  rename(`N features in left component only, completely missing from right dataset` = n_left_only__not_in_other_dataset) %>%
  rename(`N features in right component only, completely missing from left dataset` = n_right_only__not_in_other_dataset) %>%
  rename(`Odds ratio` = odds_ratio) %>%
  rename(`FDR of Fisher's exact test` = fisher_fdr) %>%
  write_csv("docs/Table_S6.csv")
```

## Plot overlaps - circus plot

```{r fig.width=8, fig.height=8, eval=F}
tmp <- module_intersections %>% 
  filter(n_intersection >= 2 & fisher_fdr <= 0.1) %>% 
  select(module_left, ds_left, module_right, ds_right, fisher_fdr) %>% 
  mutate(score = -log10(fisher_fdr))

tmp$score2 <- 1 - (tmp$score / max(tmp$score))

all_modules <- module_stats_summary %>% 
  mutate(dataset_module = paste(dataset, module, sep = ' / ')) %>%
  mutate(is_predictive = (mean_module_auc>0.7)) %>%
  select(dataset_module, dataset, module, is_predictive) %>%
  group_by(dataset) %>%
  mutate(n_modules_total = n(), line_id = row_number()) %>%
  ungroup() %>%
  mutate(gap_after = ifelse(line_id == n_modules_total, 3, 0)) %>%
  arrange(dataset_module) 

# Highlight modules that include a specific species  
# B.longum_modules <- gsub('\'','20',unique(paste(all_plots$T__Bifidobacterium_longum$data$dataset, all_plots$T__Bifidobacterium_longum$data$module, sep = ' / ')))
# tmp$B_longum_pair <- (tmp$module_left %in% B.longum_modules) & (tmp$module_right %in% B.longum_modules)  
# all_modules$has_B_longum <- all_modules$dataset_module %in% B.longum_modules

circos.clear()
circos.par(gap.degree = all_modules$gap_after)

# Init plot
circos.initialize(all_modules$dataset_module, xlim = c(0, 1))
circos.track(ylim = c(0, 1), track.height = 0.06)

# Color by dataset
# dark2_palette <- brewer.pal(8, "Dark2")
ds_to_color <- colorRampPalette(c('grey40','darkorchid4','blue4','dodgerblue4',
                                  'grey40','cadetblue3','darkolivegreen3','forestgreen','grey40'))(n_distinct(all_modules$dataset)) 
set.seed(76)
ds_to_color <- sample(ds_to_color)
names(ds_to_color) <- unique(all_modules$dataset)

for(ds in unique(all_modules$dataset)) {
  mods_in_ds <- all_modules %>% filter(dataset==ds) %>% pull(dataset_module)
  highlight.sector(mods_in_ds, 
                   track.index = 1, 
                   text = ds, #paste0(substr(ds, 1, 8),'.'),
                   facing = "bending.inside", 
                   niceFacing = F, 
                   text.vjust = "8mm", 
                   cex = 1.4, 
                   col = add_transparency(ds_to_color[ds], 0.7))
}

# Further highlight predictive modules
for(i in 1:nrow(all_modules)) {
  if (all_modules$is_predictive[i]) {
    #highlight.sector(c(all_modules$dataset_module[i]), track.index = 1, col = ds_to_color[all_modules$dataset[i]])
    circos.points(x = 0.5, y = 0.5, sector.index = all_modules$dataset_module[i], track.index = 1, cex = 1.5, pch = 16)
  }
  # if (all_modules$has_B_longum[i]) {
  #   circos.points(x = 0.5, y = 0.5, sector.index = all_modules$dataset_module[i], track.index = 1, cex = 1.5, pch = 16, col = 'darkorange3')
  # }
}

# Draw links
for(i in 1:nrow(tmp)) {
  circos.link(
    sector.index1 = paste(tmp$ds_left[i], '/', tmp$module_left[i]), 
    point1 = c(0, 1), 
    sector.index2 = paste(tmp$ds_right[i], '/', tmp$module_right[i]), 
    point2 = c(0, 1), 
    col = add_transparency(
      'grey', #ifelse(tmp$B_longum_pair[i], 'darkorange3', 'grey'),  
      transparency = tmp$score2[i]
      ),
    h.ratio = 0.8)
}

circos.clear()

#dev.off()
```
# 10. Network visualization

Network visualization with CytoScape / [iGraph](https://kateto.net/network-visualization):

```{r fig.height=7, fig.width=5, eval = FALSE, message = FALSE}
library(igraph)
library(RCy3)

for(i in 1:nrow(modules_overview)) {
  
  # Skip trivial modules
  if (is.na(modules_overview$avg_pears_corr[i])) next;
  if (modules_overview$avg_pears_corr[i] < 0.3) next;
  if (modules_overview$mean_module_auc[i] < 0.6) next;
  if (modules_overview$n_feats[i] > 20) next;
  if (modules_overview$n_feats[i] < 4) next;
  
  # Extract dataset name and module ID
  d <- modules_overview$dataset[i]
  modu <- as.numeric(gsub('module','',modules_overview$module[i]))
  edge_cutoff <- gsub('keep_1[0-9]//des_0\\.[0-9]//nrep_10//nfol_5//ncom_5//edge_','',
                      modules_overview$run_id[i]) %>% as.numeric()
  
  # Create list of edges 
  feats_to_plot <- sens_analysis_modules %>%
    filter(dataset == d) %>%
    filter(module == modu) %>%
    pull(feature) %>%
    unique()
  
  edges <- feat_pairs[[d]] %>%
    filter((feature.x %in% feats_to_plot) & 
             (feature.y %in% feats_to_plot)) %>%
    # Take only edges where features appeared together >70%/80% of the time
    filter(N >= edge_cutoff * 50) %>%
    rename(`source` = feature.x) %>%
    rename(target = feature.y) %>%
    mutate(abs_spearman = abs(spearman_r)) %>%
    mutate(spearman_signif = 
             ifelse(spearman_fdr < 0.1 & spearman_r > 0, 
                    'Positive correlation', 
                    'Non-significant correlation')) %>%
    mutate(spearman_signif = 
             ifelse(spearman_fdr < 0.1 & spearman_r < 0, 
                    'Negative correlation', 
                    spearman_signif)) 
  
  # Convert to pretty names
  edges <- edges %>%
    mutate(source = get_pretty_names(source, feat_name_fixes)) %>%
    mutate(target = get_pretty_names(target, feat_name_fixes))
  
  # Dummy list of nodes
  vertices <- edges %>% 
    select(`source`) %>% 
    rename(id = `source`) %>%
    distinct() %>%
    mutate(type = substr(id, 2, 2)) %>%
    mutate(color = gplots::col2hex(feature_type_color_map[type])) 
  
  # Export to CytoScape
  createNetworkFromDataFrames(
    nodes = vertices, 
    edges = edges %>% filter(`source` > target), 
    title = paste(d, modu, 'V1', sep = '_'), 
    collection = 'minttea_modules_V2'
    )
}

rm(edges, vertices, d, modu, feats_to_plot, i, edge_cutoff)
```

# 11. Alternative visualization

```{r fig.width=10, fig.height=9}
final_grid_plots <- list()
label_colors <- c('disease'='darkred','healthy'='grey60')

for(i in 1:nrow(modules_overview)) {
  
  # Skip trivial modules
  if (is.na(modules_overview$avg_pears_corr[i])) next;
  if (modules_overview$avg_pears_corr[i] < 0.3) next;
  if (modules_overview$mean_module_auc[i] < 0.6) next;
  if (modules_overview$n_feats[i] > 20) next;
  if (modules_overview$n_feats[i] < 4) next;
  
  # Extract dataset name and module ID
  d <- modules_overview$dataset[i] %>% unname()
  modu <- modules_overview$module[i]
  
  # Get features
  feats_to_plot <- sens_analysis_modules %>%
    filter(dataset == d) %>%
    filter(module == modu) %>%
    pull(feature) %>%
    unique()
  
  tmp <- bind_cols(lapply(diablo_input[[d]]$X, function(x) data.frame(x) %>% select(any_of(feats_to_plot))))
  tmp <- bind_cols(tmp, label = diablo_input[[d]]$Y)
  
  # Prettier names
  # TODO
  names(tmp) <- substr(names(tmp), 0, 26)
  feats_to_plot <- substr(feats_to_plot, 0, 26)
  tmp_all_utests <- all_utests %>% mutate(feature = substr(feature,0,26))
    
  # Boxplots (left stripe)
  boxplots <- list()
  for (feat in rev(feats_to_plot)) {
    # Get U-test significance
    signif_mark <- get_signif_mark(
      tmp_all_utests %>% 
        filter(dataset == d) %>% 
        filter(feature == feat) %>% 
        pull(fdr_utest)
      )
    
    # Get feature type
    feat_type = substr(feat,0,1)
    
    # Save boxplot
    p <- ggplot(tmp, aes_string(x = 'label', y = feat, fill = 'label')) +
      geom_boxplot(width = 0.8, outlier.size = 1) +
      scale_fill_manual(values = label_colors) +
      theme_bw() +
      theme(legend.position = 'none') +
      theme(axis.text.x = element_blank()) +
      theme(axis.text.y = element_text(size = 7)) +
      theme(axis.title.x = element_blank()) +
      theme(axis.title.y = element_text(
        size = 11, 
        angle = 0, 
        color = feature_type_color_map[feat_type],
        vjust = 0.5,
        hjust = -1
        )) +
      theme(plot.margin = margin(0,1,1,10)) +
      theme(panel.grid.major.x = element_blank())
    
    if (signif_mark != '') {
      p <- p +
        scale_y_continuous(expand = expansion(mult = c(0,0.1))) +
        geom_errorbarh(
          aes(y = 0.97*max(tmp[[feat]])),
          xmax = 2.2, xmin = 0.8,
          inherit.aes = F,
          linewidth = 1,
          color = 'darkred',
          height = 0) +
        geom_text(
          aes(y = 0.98*max(tmp[[feat]]), x = 1.5),
          inherit.aes = F,
          color = 'darkred',
          size = 6,
          label = signif_mark
        )
    }
    
    boxplots[[feat]] <- p
  }
  
  # Scatter plots (grid)
  scatters <- list()
  for (k in length(feats_to_plot):1) {
    feat1 = feats_to_plot[k]
    for (j in 1:(length(feats_to_plot)-1)) {
      feat2 = feats_to_plot[j]
      if (j>=k) {
        p <- ggplot() + theme_void()
      } else {
        p <- ggplot(tmp, aes_string(x = feat2, y = feat1, color = 'label', group = 'label')) +
          geom_point(size = 0.5) +
          geom_smooth(aes(fill = label), method = "lm", alpha = 0.2, formula = 'y~x') +
          scale_color_manual(values = label_colors) +
          scale_fill_manual(values = label_colors) +
          scale_x_continuous(position = 'top') +
          theme_bw() +
          theme(legend.position = 'none') +
          #theme(axis.text = element_text(size = 6)) +
          #theme(axis.title = element_text(size = 7)) +
          theme(axis.title.y = element_blank()) +
          theme(axis.text = element_blank()) +
          theme(axis.ticks = element_blank()) +
          theme(plot.margin = margin(0,1,1,0)) +
          theme(axis.title.x.top = element_text(
            color = feature_type_color_map[substr(feat2,0,1)],
            angle = 90, 
            hjust = 1, vjust = 0.5))
        
        if (k < length(feats_to_plot)) p <- p + theme(axis.title.x.top = element_blank())
      }
      scatters[[paste(k,'/',j)]] <- p
    }
  }
  
  # Combine all plots together
  all_plots <- list()
  ii <- length(feats_to_plot)-1
  for (k in 1:length(feats_to_plot)) {
    all_plots <- c(all_plots, list(boxplots[[feats_to_plot[k]]]), scatters[(ii*(k-1)+1) : (ii*k)])
  }
  p <- wrap_plots(
    all_plots, 
    nrow = length(feats_to_plot), 
    ncol = length(feats_to_plot), 
    widths = c(1,rep(2,(ii)))
    )

  # Save
  final_grid_plots[[paste(d,'/',modu)]] <- p
}
rm(ii, feat, feat1, feat2, p, tmp, tmp_all_utests, i, j, k, scatters, boxplots, d, modu)
```

```{r fig.width=10, fig.height=10}
final_grid_plots$`CD (Franzosa, 2019) / module2`
```



# Session info

```{r}
sessionInfo()
```


